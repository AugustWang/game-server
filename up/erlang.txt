1、浮点数：div整数除,rem取余
2、元组：{}
3、原子：用来表示不同的非数值常量
4、字符串:一个整数列表，""括起来
5、列表：[] 存储数目可变的东西；分表头和表尾
6、变量：大写字母开头，单一赋值
7、模式匹配：Lhs=Rhs
8、f().会让shell释放所绑定过的所有变量。

顺序型编程：高阶函数fun、断言guard、记录record、case语句、if语句
模块：子句以分号分隔，最后一句以点结束；一个子句都有函数头和一个函数体
-module(moduleName).
-export([Name/N]). %%表示带N个参数的Name函数,N为函数的运算目

shell中编译和运行：
> c(moduleName).
> pwd(). %%当前工作的目录
> cd("e:/work"). %%切换到e:\work目录

同名不同目的函数：名字相同，参数数量不同

fun:匿名函数  
> Z = fun(X) -> 2*X end.
> Z(5).

以fun为参数的函数：

声明-import(lists,[map/2,sum/1])意味着函数map/2是从lists模块中导入，
也就是可以用map(Fun,..)而不用lists:map(Fun,..);

声明-export([total/1])意味着函数total/1能够在模块之外调用，
只有从一个模块中导出的函数才能在模块之外调用；

简单列表处理：
lists:max([1,2,3]).
lists:reverse([1,2,3]).
lists:split(2,[3,4,5,6]).
lists:sum([3,4,7,8]).
lists:zip([2,3,4],[6,7,8]).
lists:delete(2,[4,5,6,78]).
lists:last([]).
lists:member(5,[5,6]).
lists:nth(2,[4,5,7]).
length([2,4,5]).


列表解析：[2*X || X <- L].
记号[F(X) || X <- L]代表由F(X)组成的列表，其中X是取值于列表L，
所有执行后是列表L中的每个元素X乘以2的列表

断言guard：
max(X,Y) when X>Y -> X;
max(X,Y) -> Y.

记录record:
-record(Name,{key1=val,key2=val}).%%包含在源码中or以.hrl文件保存

shell中读取记录rr(read record的缩写)：rr("records.hrl").

创建和更新记录：
X=#record_name{}.
X1 = #record_name{change}.
X2 = X1#record_name{}.

从记录中提取字段值：X2#record_name.key1.
shell释放掉记录todo：rf(todo).

case/if表达式

case表达式：
case expression of
	pattern1 [when ] -> expr;
	...
end

if表达式：
if
	Guard1 ->
		expr;
	...
end

异常：throw(Exception)、exit(Excption)、erlang:error(Exception)
1、将会抛出异常的函数包含在try...catch表达式里面
2、or把函数调用包含在catch表达式里
try Func of
	pattern [when ] -> expressions;
	...
catch
	exceptionType:exp [when ] -> exexpr;
	...
after
	afterExpressions
end

%%
try Expr
catch
	_:_ -> ...%%捕获所有可能的错误
end.

%%
try Expr
catch
	_ -> ...  %%默认错误标签是throw
end.

BIF:built-in function(内建函数):tuple_to_list/list_to_tuple...

二进制数据：二进制以一个整数或者字符序列的形式出现，用书名号括起来；<<"hello">>,<<5,66>>
1> <<"cat">> =:= <<99,97,116>>.
true

操作二进制数据的BIF：二进制数据中的总比特数必须恰好能被8整除
list_to_binary()/split_binary()/term_to_binary()/binary_to_term()...
size(<<44,55,3>>).

比特语法：M=<<X:3,Y:7,Z:6>> %%X占3bit，Y占7bit...
封包和解包：Mem = <<Red:5,Green:6,Blue:5>>.
			<<Red:5,Green:6,Blue:5>> = Mem.

小问题集锦：
1、apply(Mod,Func,[Arg1...]):向一个模块中的某个函数传递参数并调用该函数
apply(erlang,atom_to_list,[hello]).
2、属性：语法-AtomTag(..). 预定义模块属性or用户自定义属性
-module(modName).
-import(lists,[sum/1]).
-export([Name1/Arity1,..]).
-compile(Options). %%-compile(export_all).
-vsn(Version).%指定一个模块的版本
moduleName:module_info().%%attributes/compile/exports..

用户自定义：-Sometag(Value).

3、块表达式
begin
	Expr,
	...
end

4、布尔表达式：not/and/or/xor/
5、字符集
6、注释：%
7、epp预处理器：compile:file(modName,['P']).
8、转义符
9、函数引用
10、包含文件
-include(Filename).
-include_lib(Name).
11、列表操作符++/--
12、宏：?FILE/?MODULE/?LINE
-define(Constant,Replacement).
c(modName,{d,Macro}).

-ifdef(phil).
-define(TRACE(X),io:format("TRACE ~p:~p:~p ~p~n",[?FILE,?MODULE,?LINE,X])).
-else.
-define(TRACE(X),void).
-endif.

13、在模式中使用匹配操作符：
func1([{a,b,c}=Z|T]) ->
	func2(..,Z,..)

14、数值类型
传统语法：
K进制语法：K#Digits   %%16#ab58.
$语法：$C.
15、操作符优先级
16、进程字典:erase()./put(x,23)./get(x)./erase(x).
17、引用：erlang:make_ref().
18、短路布尔表达式：Expr1 andalso Expr2.
19、下划线变量：_Var/_
some_func(X) ->
	{P,Q} = some_other_func(X),
	%%io:format("",[Q]),  %%编译提示Q没有使用过。
	P.

some_func(X) ->
	{P,_Q} = some_other_func(X),%%加下划线不会报告警告
	%%io:format("",[_Q]),
	P.
"_"在match的时候当作一个占位符，
下划线开头变量是被忽略的，声明了没有使用/绑定也没有关系
> {A, _int, [B|_int], {B}} = {abc, 23, [22, 23], {22}}  %%会出错
因为第一个_int匹配的是int 23,第二个是list [23].
	
编译并运行程序：
停止：q()./erlang:halt()./ctrl+break.
q(). == init:stop()
运行：erlc ModName.erl %%编译ModName.erl文件，生成ModName.beam文件；
	  erl -noshell -s ModName startName -s init stop  %%运行函数ModName:startName().

把程序当作escript脚本运行：
#！/usr/bin/env escript

使用makefile进行自动编译：

并发编程：spawn/send/receive
Pid = spawn(Fun)  %%创建一个新并发进程
Pid ! Message     %%向标识符为Pid进程发送消息
receive			  %%接收一个发给当前进程的消息
	Pat [when Guard] ->
		Expres...
end

带超时的receive
receive
	Pattern ->
		Exp;
	...
after Time ->
	Exp
end.

注册进程：
register(AnAtom,Pid).
unregister(AnAtom)
whereis(AnAtom) -> Pid | undefined
registed() -> [AnAtom::atom()]


==========

gen_server起步：
1、确定一个回调模块的名称，
2、写接口函数
3、在回调模块中写需要的6个回调函数

-behaviour(Mod) %%关键字，用于告知编译器在我们没有定义适当的回调函数时给出错误信息。

gen_server:start_link()

handle_cast(_Msg, State) -> {noreply, State}.		%% 实现通知，处理异步调用的回调函数
handle_info(_Info, State) -> {noreply, State}.		%% 发给服务器原生消息
terminate(_Reason, _State) -> ok.                   %% 终止服务器调用
code_change(_OldVsn, State, _Extra) -> {ok, State}.  %% 热代码替换